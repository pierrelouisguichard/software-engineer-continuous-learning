1. Sorting Algorithms
Merge Sort: Used in problems requiring stable sorting or sorting linked lists.
Quick Sort: Often preferred for its in-place sorting capabilities and average-case time complexity.
Heap Sort: Useful in problems where the k largest/smallest elements need to be found.
2. Searching Algorithms
Binary Search: Frequently used in problems involving sorted arrays, especially when looking for specific elements or the insertion index.
Problem Examples: Search Insert Position, Find Minimum in Rotated Sorted Array.
3. Two-Pointer Algorithms
Efficient for problems involving arrays or strings where you need to maintain two pointers that traverse the data from either end or both ends.
Problem Examples: Two Sum II, Container With Most Water, 3Sum.
4. Sliding Window Algorithms
Useful for finding subarrays or substrings that meet specific criteria.
Problem Examples: Longest Substring Without Repeating Characters, Minimum Size Subarray Sum, Sliding Window Maximum.
5. Greedy Algorithms
Interval Scheduling: Selecting the maximum number of non-overlapping intervals.
Greedy Choice Property: Frequently applied in problems where local optimality leads to global optimality.
Problem Examples: Jump Game, Partition Labels, Gas Station.
6. Dynamic Programming (DP) Algorithms
Memoization/Tabulation: Fundamental in solving complex problems by breaking them down into overlapping subproblems.
Problem Examples: Climbing Stairs, House Robber, Longest Increasing Subsequence, Coin Change, Edit Distance.
7. Graph Algorithms
Depth-First Search (DFS): Used to explore all possible paths, commonly in tree problems.
Breadth-First Search (BFS): Best suited for shortest-path problems in unweighted graphs.
Problem Examples: Number of Islands, Course Schedule, Word Ladder, Clone Graph.
8. Backtracking Algorithms
Backtracking is key for problems involving combinations, permutations, or constraint satisfaction.
Problem Examples: N-Queens, Sudoku Solver, Word Search, Permutations.
9. Union-Find (Disjoint Set Union)
Commonly used in problems involving connected components, finding cycles, or clustering.
Problem Examples: Number of Connected Components, Accounts Merge, Graph Valid Tree.
10. String Matching Algorithms
KMP (Knuth-Morris-Pratt) and Rabin-Karp are occasionally useful for pattern matching problems.
Problem Examples: Implement strStr(), Longest Palindromic Substring.
11. Divide and Conquer Algorithms
Frequently employed in problems involving recursive subproblems.
Problem Examples: Merge Sort, Search in Rotated Sorted Array, Maximum Subarray.
12. Topological Sorting
Useful in problems involving dependency ordering or scheduling.
Problem Examples: Course Schedule, Alien Dictionary.
13. Bit Manipulation Algorithms
Efficient for problems that involve binary representations or counting bits.
Problem Examples: Single Number, Counting Bits, Reverse Bits.
14. Heap (Priority Queue) Algorithms
Heaps are great for problems that involve finding the top K elements or merging sorted lists.
Problem Examples: Merge k Sorted Lists, Find Median from Data Stream, Top K Frequent Elements.
15. Trie (Prefix Tree) Algorithms
Tries are useful for problems involving strings or prefixes.
Problem Examples: Implement Trie (Prefix Tree), Word Search II, Replace Words.